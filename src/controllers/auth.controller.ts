// src/controllers/auth.controller.ts
import { Request, Response } from "express";
import { AppDataSource } from "../config/data-source";
import { Admin } from "../entities/Admin";
import bcrypt from "bcrypt";
import jwt from "jsonwebtoken";
import { AuthRequest } from "../middlewares/authMiddleware";
import { copyHotelDataFromAdmin } from "../utils/copyHotelDataFromAdmin";
import type { LoginRequestDto, LoginResponseDto } from "../dto/auth.dto";
import { ROLES, Role } from "../auth/roles";
import { isHour, isHourOptional } from "../utils/hours";

const JWT_SECRET = process.env.JWT_SECRET as string;

/**
 * üîê POST /auth/create-admin ‚Äî superadmin only
 * Body:
 *  - username, password, confirmPassword, hotel_name, address, ...
 *  - checkInHour?: number(0..23)
 *  - checkOutHour?: number(0..23)
 */
export const createAdminBySuperadmin = async (
  req: AuthRequest,
  res: Response
) => {
  // ‚ùó Safety check: even if route is protected by middleware, double-check role here.
  if (!req.user || req.user.role !== ROLES.SUPER) {
    return res.status(403).json({ message: "Superadmin only" });
  }
  const {
    username,
    password,
    confirmPassword,
    hotel_name,
    address,
    full_name,
    phone,
    email,
    checkInHour,
    checkOutHour,
  } = req.body as {
    username: string;
    password: string;
    confirmPassword: string;
    hotel_name: string;
    address: string;
    full_name?: string;
    phone?: string;
    email?: string;
    checkInHour?: number;
    checkOutHour?: number;
  };

  if (!username || !password || !confirmPassword || !hotel_name || !address) {
    return res.status(400).json({
      message:
        "username, password, confirmPassword, hotel_name and address are required",
    });
  }

  if (password !== confirmPassword) {
    return res.status(400).json({ message: "Passwords do not match" });
  }

  // Optional policy hours validation (0..23 if provided)
  if (!isHourOptional(checkInHour) || !isHourOptional(checkOutHour)) {
    return res
      .status(400)
      .json({ message: "checkInHour/checkOutHour must be integers in 0..23" });
  }

  const adminRepo = AppDataSource.getRepository(Admin);
  const existing = await adminRepo.findOneBy({ username });

  if (existing) {
    return res.status(400).json({ message: "Username already exists" });
  }

  const hashedPassword = await bcrypt.hash(password, 10);

  // Create entity with hotel defaults.
  // If hours provided ‚Üí override; else entity defaults (14/10) will be used.
  const newAdmin = adminRepo.create({
    username,
    password: hashedPassword,
    role: ROLES.ADMIN,
    isBlocked: false,
    hotel_name,
    address,
    full_name,
    phone,
    email,
    ...(typeof checkInHour !== "undefined" ? { checkInHour } : {}),
    ...(typeof checkOutHour !== "undefined" ? { checkOutHour } : {}),
  });

  const saved = await adminRepo.save(newAdmin);

  res.status(201).json({
    message: `Admin "${saved.username}" created successfully`,
    adminId: saved.id,
    policy: {
      checkInHour: saved.checkInHour,
      checkOutHour: saved.checkOutHour,
    },
  });
};

/**
 * üîê GET /auth/users
 * - superadmin: returns only hotel admins + nested editors
 * - admin: returns only their editors
 * - editor: forbidden
 */
export const getUsers = async (req: AuthRequest, res: Response) => {
  const adminRepo = AppDataSource.getRepository(Admin);
  const { adminId, role } = req.user!;

  // —Ä–µ–¥–∞–∫—Ç–æ—Ä –Ω–µ –º–∞—î –¥–æ—Å—Ç—É–ø—É
  if (role === ROLES.EDITOR) {
    return res.status(403).json({ message: "Editors cannot access user list" });
  }

  // superadmin ‚Üí —Ç—ñ–ª—å–∫–∏ –∞–¥–º—ñ–Ω–∏ (–±–µ–∑ editor), –∞–ª–µ –∑ –≤–∫–ª–∞–¥–µ–Ω–∏–º–∏ editor‚Äô–∞–º–∏
  if (role === ROLES.SUPER) {
    const admins = await adminRepo.find({
      where: { role: ROLES.ADMIN },
      relations: ["createdEditorAdmins"],
      order: { username: "ASC" },
    });

    // –ü—Ä–∏–±–µ—Ä–µ–º–æ password —ñ –ø–æ–≤–µ—Ä–Ω–µ–º–æ editors –≤–∫–ª–∞–¥–µ–Ω–æ
    const data = admins.map((a) => ({
      id: a.id,
      username: a.username,
      role: a.role,
      hotel_name: a.hotel_name,
      address: a.address,
      full_name: a.full_name,
      logo_url: a.logo_url,
      phone: a.phone,
      email: a.email,
      isBlocked: a.isBlocked,
      checkInHour: a.checkInHour, // üëà show hotel policy
      checkOutHour: a.checkOutHour, // üëà show hotel policy
      createdAt: a.createdAt,
      updatedAt: a.updatedAt,
      editorsCount: a.createdEditorAdmins?.length ?? 0,
      editors: (a.createdEditorAdmins || []).map((e) => ({
        id: e.id,
        username: e.username,
        role: e.role, // –∑–∞–≤–∂–¥–∏ "editor"
        full_name: e.full_name,
        phone: e.phone,
        email: e.email,
        isBlocked: e.isBlocked,
        createdAt: e.createdAt,
        updatedAt: e.updatedAt,
        // –ù—ñ—á–æ–≥–æ –∑–∞–π–≤–æ–≥–æ (–±–µ–∑ password, –±–µ–∑ createdBy)
      })),
    }));

    return res.json(data);
  }

  // admin ‚Üí —è–∫ —ñ –±—É–ª–æ: —Ç—ñ–ª—å–∫–∏ —Å–≤–æ—ó —Ä–µ–¥–∞–∫—Ç–æ—Ä–∏ –ø–ª–æ—Å–∫–∏–º —Å–ø–∏—Å–∫–æ–º (–∞–±–æ —Ö–æ—á–µ—à ‚Äî –º–æ–∂—É –∑—Ä–æ–±–∏—Ç–∏ –∑ –±–ª–æ–∫–æ–º self + editors)
  if (role === ROLES.ADMIN) {
    const editors = await adminRepo.find({
      where: { createdBy: { id: adminId }, role: ROLES.EDITOR },
      order: { username: "ASC" },
    });

    // –ü—Ä–∏–±—Ä–∞—Ç–∏ password
    const data = editors.map((e) => ({
      id: e.id,
      username: e.username,
      role: e.role, // "editor"
      full_name: e.full_name,
      phone: e.phone,
      email: e.email,
      isBlocked: e.isBlocked,
      createdAt: e.createdAt,
      updatedAt: e.updatedAt,
    }));

    return res.json(data);
  }
};

/**
 * üîê POST /auth/login ‚Äî admin or editor login
 * Payload:
 *  - For editor: adminId = owner's id (createdBy.id)
 *  - For admin:  adminId = own id
 * The same payload shape is preserved for middleware/guards.
 */
export const loginAdmin = async (req: Request, res: Response) => {
  const { username, password } = req.body as LoginRequestDto;

  // 1) –®—É–∫–∞—î–º–æ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞
  const adminRepository = AppDataSource.getRepository(Admin);
  // –í–ê–ñ–õ–ò–í–û: —Ç—è–≥–Ω–µ–º–æ createdBy, –±–æ –¥–ª—è editor –ø–æ—Ç—Ä—ñ–±–µ–Ω –≤–ª–∞—Å–Ω–∏–∫ –≥–æ—Ç–µ–ª—é
  const admin = await adminRepository.findOne({
    where: { username },
    relations: ["createdBy"],
  });

  if (!admin) {
    return res.status(401).json({ message: "Invalid credentials" });
  }
  if (admin.role === ROLES.ADMIN && admin.isBlocked) {
    return res.status(403).json({ message: "Account is blocked" });
  }
  if (admin.role === ROLES.EDITOR && admin.createdBy?.isBlocked) {
    return res
      .status(403)
      .json({ message: "Admin is blocked ‚Äî editor access denied" });
  }
  const isMatch = await bcrypt.compare(password, admin.password);
  if (!isMatch) {
    return res.status(401).json({ message: "Invalid credentials" });
  }

  // üëá –ö–õ–Æ–ß–ï–í–û–ï: –¥–ª—è editor –∫–ª–∞–¥—ë–º adminId = id –≤–ª–∞–¥–µ–ª—å—Ü–∞ –æ—Ç–µ–ª—è (createdBy.id)
  const ownerAdminId =
    admin.role === ROLES.EDITOR ? admin.createdBy!.id : admin.id;

  // ‚úÖ –¢–æ–∫–µ–Ω –ù–ï –º—ñ–Ω—è—î–º–æ ‚Äî payload –∑–∞–ª–∏—à–∞—î—Ç—å—Å—è —Ç–∏–º —Å–∞–º–∏–º, —â–æ–± middleware/–∫–æ–Ω—Ç—Ä–æ–ª–µ—Ä–∏ –ø—Ä–∞—Ü—é–≤–∞–ª–∏ —è–∫ –∑–∞—Ä–∞–∑
  // adminId = id –≤–ª–∞—Å–Ω–∏–∫–∞ –≥–æ—Ç–µ–ª—é (–¥–ª—è editor ‚Äî —Ü–µ –π–æ–≥–æ createdBy)
  const token = jwt.sign(
    {
      adminId: ownerAdminId, // –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä–∞–º–∏ rooms/stays
      role: admin.role as Role, // 'superadmin' | 'admin' | 'editor'
      sub: admin.id, // —Ñ–∞–∫—Ç–∏—á–µ—Å–∫–∏–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å (–∫—Ç–æ –∑–∞–ª–æ–≥–∏–Ω–∏–ª—Å—è)
    },
    JWT_SECRET,
    { expiresIn: "48h" }
  );
  // üÜï –í—ñ–¥–ø–æ–≤—ñ–¥—å: –≤—ñ–¥–¥–∞—î–º–æ –ø—Ä–æ—Ñ—ñ–ª—å –¥–ª—è —Ñ—Ä–æ–Ω—Ç–∞
  const policy =
    admin.role === "admin"
      ? { checkInHour: admin.checkInHour, checkOutHour: admin.checkOutHour }
      : admin.createdBy
      ? {
          checkInHour: admin.createdBy.checkInHour,
          checkOutHour: admin.createdBy.checkOutHour,
        }
      : undefined;

  const payload: LoginResponseDto = {
    token,
    username: admin.username,
    role: admin.role as Role,
    adminId: ownerAdminId,
    // –î–ª—è admin ‚Äî –±–µ—Ä–µ–º–æ —Å–≤–æ—î hotel_name; –¥–ª—è editor ‚Äî hotel_name –≤–ª–∞—Å–Ω–∏–∫–∞
    hotelName:
      admin.role === ROLES.ADMIN
        ? admin.hotel_name ?? undefined
        : admin.createdBy?.hotel_name ?? undefined,

    // üëá –ø—Ä–∏ –∂–µ–ª–∞–Ω–∏–∏ –º–æ–∂–Ω–æ —Å—Ä–∞–∑—É –æ—Ç–¥–∞—Ç—å –∏ —á–∞—Å—ã –¥–µ—Ñ–æ–ª—Ç–æ–≤ –æ—Ç–µ–ª—è:
    ...(policy ? { policy } : {}),
  };
  return res.json({ payload });
};

/**
 * üîê POST /auth/create-editor ‚Äî only admin can create editors
 * Copies hotel profile (including policy hours) from owner admin.
 */
export const createEditorAdmin = async (req: AuthRequest, res: Response) => {
  const { username, password, confirmPassword, full_name, phone, email } =
    req.body as {
      username: string;
      password: string;
      confirmPassword: string;
      full_name?: string;
      phone?: string;
      email?: string;
    };
  const creatorId = req.user!.adminId;

  // —Ç–æ–ª—å–∫–æ admin –º–æ–∂–µ—Ç —Å–æ–∑–¥–∞–≤–∞—Ç—å —Ä–µ–¥–∞–∫—Ç–æ—Ä–æ–≤
  if (req.user!.role !== "admin") {
    return res.status(403).json({ message: "Only admin can create editors" });
  }

  if (!username || !password || !confirmPassword) {
    return res
      .status(400)
      .json({ message: "username, password and confirmPassword are required" });
  }

  if (password !== confirmPassword) {
    return res.status(400).json({ message: "Passwords do not match" });
  }

  const adminRepo = AppDataSource.getRepository(Admin);

  // üîπ –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∞–¥–º–∏–Ω–∞, –∫–æ—Ç–æ—Ä—ã–π —Å–æ–∑–¥–∞—ë—Ç editor
  const creatorAdmin = await adminRepo.findOneBy({ id: creatorId });

  if (!creatorAdmin) {
    return res.status(404).json({ message: "Creator admin not found" });
  }
  const existing = await adminRepo.findOneBy({ username });

  if (existing) {
    return res.status(400).json({ message: "Username already exists" });
  }

  const hashedPassword = await bcrypt.hash(password, 10);

  // –ò—Å–ø–æ–ª—å–∑—É–µ–º helper –¥–ª—è –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –æ—Ç–µ–ª—è
  // Copy hotel profile + policy hours from owner
  const hotelData = copyHotelDataFromAdmin(creatorAdmin);

  // –°–æ–∑–¥–∞—ë–º –Ω–æ–≤–æ–≥–æ —Ä–µ–¥–∞–∫—Ç–æ—Ä–∞ —Å –¥–∞–Ω–Ω—ã–º–∏ –æ—Ç–µ–ª—è –∏ —Å–æ–∑–¥–∞—Ç–µ–ª—è
  const newEditor = adminRepo.create({
    username,
    password: hashedPassword,
    role: ROLES.EDITOR,
    createdBy: creatorAdmin,
    full_name,
    phone,
    email,
    ...hotelData,
  });

  const saved = await adminRepo.save(newEditor);

  // üëá –í–ê–ñ–ù–û: adminId = creatorId (–≤–ª–∞—Å–Ω–∏–∫ –≥–æ—Ç–µ–ª—é), sub = id —Ä–µ–¥–∞–∫—Ç–æ—Ä–∞
  const token = jwt.sign(
    { adminId: creatorId, role: saved.role, sub: saved.id },
    JWT_SECRET,
    { expiresIn: "48h" }
  );

  res.status(201).json({
    message: `Editor "${saved.username}" created successfully`,
    token,
  });
};

/**
 * üîí PUT /auth/block/:username ‚Äî block admin and all their editors
 */
export const blockAdmin = async (req: AuthRequest, res: Response) => {
  const username = req.params.username;
  const adminRepo = AppDataSource.getRepository(Admin);
  const target = await adminRepo.findOne({
    where: { username },
    relations: ["createdEditorAdmins"],
  });

  if (!target || target.role !== ROLES.ADMIN) {
    return res.status(404).json({ message: "Admin not found" });
  }

  target.isBlocked = true;
  // üëâ –ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –±–ª–æ—á–∏–º–æ –≤—Å—ñ—Ö editor'—ñ–≤, —è–∫–∏—Ö –≤—ñ–Ω —Å—Ç–≤–æ—Ä–∏–≤
  for (const editor of target.createdEditorAdmins) {
    editor.isBlocked = true;
  }
  await adminRepo.save([target, ...target.createdEditorAdmins]);
  res.json({ message: `Admin ${username} and all editors blocked` });
};

/**
 * üîì PUT /auth/unblock/:username ‚Äî unblock admin and all their editors
 */
export const unblockAdmin = async (req: AuthRequest, res: Response) => {
  const username = req.params.username;
  const adminRepo = AppDataSource.getRepository(Admin);
  const target = await adminRepo.findOne({
    where: { username },
    relations: ["createdEditorAdmins"],
  });

  if (!target || target.role !== ROLES.ADMIN) {
    return res.status(404).json({ message: "Admin not found" });
  }

  target.isBlocked = false;
  // üëâ –†–æ–∑–±–ª–æ–∫–æ–≤—É—î–º–æ –≤—Å—ñ—Ö editor'—ñ–≤
  for (const editor of target.createdEditorAdmins) {
    editor.isBlocked = false;
  }

  await adminRepo.save([target, ...target.createdEditorAdmins]);

  res.json({ message: `Admin ${username} and all editors unblocked` });
};

/**
 * ‚ùå DELETE /auth/delete/:username
 * - superadmin can delete anyone
 * - admin can delete their editors (not themselves)
 * - editor cannot delete
 */
export const deleteAdminOrEditor = async (req: AuthRequest, res: Response) => {
  const requesterId = req.user!.sub; // actual logged-in user id
  const ownerId = req.user!.adminId; // hotel owner id
  const requesterRole = req.user!.role;
  const usernameToDelete = req.params.username;

  const adminRepo = AppDataSource.getRepository(Admin);
  const targetUser = await adminRepo.findOne({
    where: { username: usernameToDelete },
    relations: ["createdBy"],
  });

  if (!targetUser) {
    return res.status(404).json({ message: "User not found" });
  }

  if (requesterRole === ROLES.SUPER) {
    // superadmin –º–æ–∂–µ –≤–∏–¥–∞–ª–∏—Ç–∏ –±—É–¥—å-–∫–æ–≥–æ
    await adminRepo.remove(targetUser);
    return res.json({
      message: `User "${usernameToDelete}" deleted by superadmin`,
    });
  }

  if (requesterRole === ROLES.EDITOR) {
    return res.status(403).json({ message: "Editors cannot delete accounts" });
  }

  // admin –Ω–µ –º–æ–∂–µ—Ç —É–¥–∞–ª–∏—Ç—å —Å–∞–º–æ–≥–æ —Å–µ–±—è
  if (targetUser.id === requesterId) {
    return res.status(403).json({ message: "Admin cannot delete own account" });
  }

  // admin –º–æ–∂–µ—Ç —É–¥–∞–ª–∏—Ç—å —Ç–æ–ª—å–∫–æ —Å–≤–æ–µ–≥–æ editor'–∞
  const isCreatedByHim = targetUser.createdBy?.id === ownerId;
  if (!isCreatedByHim) {
    return res.status(403).json({ message: "Access denied" });
  }

  await adminRepo.remove(targetUser);
  res.json({ message: `User "${usernameToDelete}" deleted successfully` });
};
